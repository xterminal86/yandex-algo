#!/usr/bin/python3

# contest id = 88044531

#
# Временная сложность - O(n * (m + к)), где n - кол-во строк, m - длина строк,
#                       r - кол-во фрагментов, описывающих "упаковку".
#                       Поскольку кол-во строк несоразмерно их длине, то
#                       в среднем фактор количества строк можно не учитывать и
#                       принять его за O(1), т.к. основная работа будет
#                       проходить на этапе скана каждой строки из ввода.
#                       В тривиальном случае (когда "упаковка" отсутствует)
#                       имеем фулскан на n строк, т.е. (n * m).
#                       Если упаковано по уши, то (m + k).
#
# Пространственная    - O(k), где k - кол-во рекурсивных вызовов, равное кол-ву
#                       "закодированных" строк, содержащихся во входной строке.
#
# Применяется рекурсивное решение: поскольку формат "упаковки" нам известен,
# идём по "запакованной" строке и копим встреченные буквы пока не встретим цифру.
# Если встретили цифру, то запоминаем её как количество повторов того, что будет
# дальше справа, прокручиваем индекс на 2 вправо (т.к. формат предполагает
# одноразрядную цифру количества повторов, после которой идёт открывающая
# квадратная скобка), и рекурсивно вызываем функцию распаковки.
# Условием выхода из рекурсии будет достижение конца исходной "запакованной"
# строки. В случае если мы встретили закрывающую скобку, надо выйти из данного
# рекурсивного стек фрейма и намножить то, что получилось внутри, на уровне выше.
# Для этого возвращаем кортеж из двух элементов: чистые данные и индекс,
# следующий после закрывающей скобки, т.е. то, откуда мы потом продолжим скан
# по исходной строке.
# Для нахождения общего префикса нам достаточно двух строк: одну минимальной
# длины и одну максимальной. Поскольку в процессе обработки входных данных мы
# можем вычислить что-то одно, то чтобы вычислить оба параметра за один проход
# немного схитрим и будем сравнивать распакованные строки с двумя шаблонами:
# пустой строкой для поиска строки максимальной длины, и строкой максимально
# возможной по условию длины, состоящей из букв 'z', для поиска строки
# минимальной длины.
# Для корректного нахождения общего префикса необходимо использовать
# лексикографическое сравнение, т.к., например, для строк
#
# s1 = "abc"
# s2 = "abd"
# s3 = "abcc"
#
# будет верно, что s2 > s1 и s2 > s3, но s3 > s1 и s3 < s2, несмотря на то,
# что строка s3 длиннее и её префикс совпадает со строкой s1.
# Таким образом общий префикс будет ab.
#

Indent = -2;

def UnpackString(ps, ind, ans, debug=False):
  if debug:
    global Indent;
    Indent += 2;
    spaces = "." * Indent;
    print(f"{ spaces }in = { ps }, ind = { ind }");
  ln = len(ps);
  tmp = [];
  while ind < ln:
    ch = ps[ind];
    if str.isdigit(ch):
      if debug:
        print(f"{ spaces }found repeat { ch } at position { ind }");
      toRepeat = int(ch);
      ind += 2;
      (unpacked, end) = UnpackString(ps, ind, tmp, debug);
      tmp += (toRepeat * unpacked);
      ind = end;
      if debug:
        print(f"{ spaces }so far: { tmp }, i = { ind }");
    elif ch == ']':
      if debug:
        print(f"{ spaces }ret ({ tmp }, { ind + 1 })");
      Indent += -2;
      return (tmp, ind + 1);
    else:
      tmp += ch;
      ind += 1;

  ans += tmp;

################################################################################

def main():
  n = int(input().rstrip());

  upTo = 10**6;

  maxStr = "";
  minStr = "z" * upTo;

  for i in range(n):
    ans = [];
    s = input().rstrip();
    packed = list(s);
    UnpackString(packed, 0, ans);
    us = "".join(ans);

    if us < minStr:
      minStr = us;

    if us > maxStr:
      maxStr = us;

  upTo = min( len(minStr), len(maxStr) );

  for i in range(upTo):
    if minStr[i] != maxStr[i]:
      break;
    else:
      print(minStr[i], end="");

  print("");

################################################################################

if __name__ == "__main__":
  main();
