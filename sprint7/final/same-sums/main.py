#!/usr/bin/python3

# contest id = 87384032

#
# Временная сложность - O(n * limit)
# Пространственная - O(n + limit)
#

import sys;

################################################################################

def PrintDP(dp):
  ln = len(dp);
  out = "  ";
  for i in range(ln):
    out += f"{ i }) { dp[i] } ";

  print("-"*80);
  print(out);
  print("-"*80);

################################################################################

def main():
  n = int(input().rstrip());

  scores = list( map(int, sys.stdin.readline().rstrip().split()) );

  total = sum(scores);

  #
  # На мой взгляд тут есть два варианта ответа зачем нужна на первый взгляд
  # неочевидная проверка на нечётность суммы элементов массива, которая идёт
  # после данных комментариев: "простой" и сложный. :-)
  #
  # Простой: проверка нужна потому, что нечётная сумма не делится на 2 нацело.
  #
  # Сложный идёт далее:
  #
  # Сначала обратим внимание на три свойства.
  # По ним будет легко убедиться, что есть всего один вариант получить нечётное
  # число при сложении. Для этого просто переберём все цифры от 0 до 9,
  # и посмотрим на результат суммы по модулю 10, т.к. для определения
  # чётности / нечётности нас интересует лишь последний разряд числа.
  #
  # Начнём с нечётных чисел / цифр:
  #
  # [1 + 1] = 2  [3 + 3] = 6  [5 + 5] = 0  [7 + 7] = 4  [9 + 9] = 8
  # [1 + 3] = 4  [3 + 5] = 8  [5 + 7] = 2  [7 + 9] = 6
  # [1 + 5] = 6  [3 + 7] = 0  [5 + 9] = 4
  # [1 + 7] = 8  [3 + 9] = 2
  # [1 + 9] = 0
  #
  # То есть сумма нечётных чисел всегда даёт чётное число.
  #
  # Теперь посмотрим на сумму чётных чисел. Тут всё проще: самое первое чётное
  # число - это 2. Соответственно по определению чётных чисел следующее чётное
  # число будет находиться как минимум на расстоянии 2 от текущего. Значит любое
  # следующее чётное число будет находиться на расстоянии кратном двойке.
  # Сумму любых чётных чисел можно представить как сумму двоек, и таким образом
  # вследствии вышеизложенного итоговый результат будет чётным.
  # Опять-таки, так как нас не интересует порядок числа, можно смотреть только
  # на последний разряд:
  #
  # [ 4 + 8] = [(2 + 2) + (2 + 2 + 2 + 2)] = 2
  # [12 + 6] = [(2 * 6) + (2 * 3)]         = 8
  #
  # Таким образом очевидно, что для того, чтобы получить нечётное число при
  # сложении, чётность слагаемых должна быть разной:
  #
  # [1 + 4] = 5
  # [3 + 8] = 1
  #
  # Теперь вернёмся к исходному вопросу. Пойдём от обратного.
  # Если предположить, что нижеследующая проверка необязательна, то получается,
  # что в нашем массиве есть два набора элементов, которые в сумме дают
  # нечётное число. Однако это возможно только при условии, что одна из половин
  # суммы чётная, а другая нечётная, что противоречит требованию задачи -
  # проверить, можно ли заданный массив разделить на две части с одинаковой
  # суммой в обоих. Получили противоречие, следовательно если сумма элементов
  # массива является нечётной, то нет смысла даже пытаться искать одинаковую
  # сумму среди его элементов - её там просто нет. В случае edge case'а в виде
  # массива из нулей, мы не пойдём в рабочий подцикл, и в конце напечатается True
  # т.к. dp[limit] будет единственный элемент со значением True.
  #
  if total % 2 != 0:
    print("False");
    return;

  limit = total // 2;

  print(f"total = { total }, limit = { limit }");

  dp = [ False ] * (limit + 1);

  dp[0] = True;

  for score in scores:
    print(f"new score = { score }");
    for i in range(limit, score - 1, -1):
      print(f"  i = { i }, score = { score }, (i - score) = { i - score }");
      if dp[limit] == True:
        print("True");
        return;

      dp[i] = (dp[i] or dp[i - score]);
      PrintDP(dp);

  if dp[limit] == True:
    print("True");
  else:
    print("False");

################################################################################

if __name__ == "__main__":
  main();
