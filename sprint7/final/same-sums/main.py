#!/usr/bin/python3

# contest id = 87424316

# Сразу скажу, что пришлось гуглить, т.к. оптимальное решение для меня
# какая-то магия. То, что было понятно прокомментировал,
# в остальном комментарии просто по тому как реализовывается табличный метод.
# Связь между значениями в ячейках таблицы от меня ускользает - индус в ролике
# просто говорил "идёте наверх, отсчитываете влево столько-то, и берёте значение,
# а если сверху уже 1, то переносите как есть".
#
# Временная сложность - O(n * toSearch)
# Пространственная    - O(toSearch)
#

import sys;

################################################################################

def main():
  n = int(input().rstrip());

  scores = list( map(int, sys.stdin.readline().rstrip().split()) );

  total = sum(scores);

  #
  # Как мне кажется тут есть два варианта ответа зачем нужна на первый взгляд
  # неочевидная проверка на нечётность суммы элементов массива, которая идёт
  # после данных комментариев: "простой" и сложный. :-)
  #
  # Простой: проверка нужна потому, что нечётная сумма не делится на 2 нацело.
  #
  # Сложный идёт далее:
  #
  # Сначала обратим внимание на три свойства.
  # По ним будет легко убедиться, что есть всего один вариант получить нечётное
  # число при сложении. Для этого просто переберём все цифры от 0 до 9,
  # и посмотрим на результат суммы по модулю 10, т.к. для определения
  # чётности / нечётности нас интересует лишь последний разряд числа.
  #
  # Начнём с нечётных чисел / цифр:
  #
  # [1 + 1] = 2  [3 + 3] = 6  [5 + 5] = 0  [7 + 7] = 4  [9 + 9] = 8
  # [1 + 3] = 4  [3 + 5] = 8  [5 + 7] = 2  [7 + 9] = 6
  # [1 + 5] = 6  [3 + 7] = 0  [5 + 9] = 4
  # [1 + 7] = 8  [3 + 9] = 2
  # [1 + 9] = 0
  #
  # 1) То есть сумма нечётных чисел всегда даёт чётное число.
  #
  # 2) Теперь посмотрим на сумму чётных чисел. Тут всё проще: самое первое чётное
  # число - это 2. Соответственно по определению чётных чисел следующее чётное
  # число будет находиться как минимум на расстоянии 2 от текущего. Значит любое
  # следующее чётное число будет находиться на расстоянии кратном двойке.
  # Сумму любых чётных чисел можно представить как сумму двоек, и таким образом
  # вследствии вышеизложенного итоговый результат будет чётным.
  # Опять-таки, так как нас не интересует порядок числа, можно смотреть только
  # на последний разряд:
  #
  # [ 4 + 8] = [(2 + 2) + (2 + 2 + 2 + 2)] = 2
  # [12 + 6] = [(2 * 6) + (2 * 3)]         = 8
  #
  # 3) Теперь также очевидно, что для того, чтобы получить нечётное число при
  # сложении, чётность слагаемых должна быть разной:
  #
  # [1 + 4] = 5
  # [3 + 8] = 1
  #
  # Теперь вернёмся к исходному вопросу. Пойдём от обратного.
  # Если предположить, что нижеследующая проверка необязательна, то получается,
  # что в нашем массиве есть два набора элементов, которые в сумме дают
  # нечётное число. Однако, в соответствии с рассуждениями выше, это возможно
  # только при условии, что одна из половин суммы чётная, а другая нечётная,
  # что противоречит требованию задачи - проверить, можно ли заданный массив
  # разделить на две части с *одинаковой* суммой в обоих. Получили противоречие,
  # следовательно если сумма элементов массива является нечётной, то нет смысла
  # даже пытаться искать одинаковую сумму среди его элементов - её там просто нет.
  #
  if total % 2 != 0:
    print("False");
    return;

  #
  # Поскольку ищем в массиве две половины с одинаковой суммой, то у нас
  # есть верхняя граница поиска, которая равна половине суммы всех элементов
  # массива. Другого варианта быть не может, так как две половины с одинаковой
  # суммой из исходного массива при сложении очевидно дадут сумму всех элементов
  # массива.
  #
  toSearch = total // 2;

  #
  # Имея цель для поиска, осталось лишь перебрать суммы всех подсетов исходного
  # массива и если нам удалось найти сумму элементов этого подсета равной искомой,
  # то значит массив можно разделить на две части. Забрутфорсить через
  # рекурсивный обход дерева мы очевидно не можем, т.к. не пройдём по времени
  # ( которое O(2^n) ) и памяти ( O(n*sum(array)) ).
  # Другой вариант это использовать сет из сумм, в который положить первый
  # элемент и дальше перебирать суммы всех элементов исходного массива с
  # элементами этого сета, которые будут представлять собой части уже
  # посчитанных сумм, и таким образом забутстрепить решение.
  # Но в контесте предусмотрительно выставили лимит по памяти в 8 МБ и
  # максимально возможный размер числа n в 300. А размер сета из трёхсот
  # элементов в питоне как раз равен 8416 байт.
  # Поэтому придётся искать другой способ.
  #
  # Остаётся только табличный метод и динамическое программирование.
  # Допутим нам надо проверить массив [ 1, 3, 4, 2 ].
  # Сумма элементов равна 10, значит искомая сумма равна 5.
  # Тогда начальная таблица будет иметь вид:
  #
  #   0 1 2 3 4 5
  # 1 1
  # 3 1
  # 4 1
  # 2 1
  #
  # Проставляем True (т.е. 1) в нулевую колонку, потому что так надо.
  # Затем будем смотреть можем ли мы добрать числом из строки до числа из колонки.
  # 1 до 1 -> 1. 1 до 2 -> 0 и далее.
  #
  #   0 1 2 3 4 5
  # 1 1 1 0 0 0 0
  # 3 1
  # 4 1
  # 2 1
  #
  # Переходим к следующей строке, т.е. числу 3. До тех пор пока номер колонки
  # не сравняется с числом переносим значения из предыдущей строки.
  # Как только сравнялись и больше, то идём в предыдущую строку и, если она 0,
  # отсчитываем кол-во колонок равное рассматриваемому числу-строке влево и
  # записываем в текущую клетку значение оттуда. Если же сверху стоит 1, то
  # переносим его как есть.
  #
  #   0 1 2 3 4 5
  # 1 1 1 0 0 0 0
  # 3 1 1 0 1 1 0
  # 4 1 1 0 1 1 1
  # 2 1 1 1 1 1 1
  #
  # Наш ответ будет находиться в правой нижней ячейке.
  # Двойной массив не влезет в лимиты по памяти контеста, так что опять облом.
  # Но можно заметить, что на каждой итерации мы не модифицируем значения левее
  # рассматриваемого, а если в предыдущей строке уже было выставлено 1, то оно
  # по любому пойдёт вниз.
  # Поэтому нетрудно убедиться, что двойной массив можно заменить на одинарный,
  # при этом ответ будем искать в последней ячейке, т.е. будем искать ответ на
  # вопрос можем ли мы набрать сумму до искомой или нет.
  #

  dp = [ False ] * (toSearch + 1);
  dp[0] = True;

  for score in scores:
    for i in range(toSearch, score - 1, -1):
      #
      # Если ответ уже готов, то дальше можно не искать.
      #
      if dp[toSearch] == True:
        print("True");
        return;

      dp[i] = (dp[i] or dp[i - score]);

  #
  # Проверяем ответ.
  #
  if dp[toSearch] == True:
    print("True");
  else:
    print("False");

################################################################################

if __name__ == "__main__":
  main();
