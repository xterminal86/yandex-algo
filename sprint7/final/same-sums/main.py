#!/usr/bin/python3

# contest id = 87484206
#
# Формат ввода
# В первой строке записано целое число n (0 ≤ n ≤ 300) –— количество выигранных
# партий.
#
# Во второй строке через пробел записано n целых неотрицательных чисел, каждое
# из которых не превосходит 300 –— заработанные в партиях очки.
#
# Формат вывода
# Нужно вывести True, если произвести такое разбиение возможно, иначе —– False
#
# Временная сложность - O(n * toSearch)
# Пространственная    - O( 2*(toSearch + 1) )

import sys;

################################################################################

def main():
  n = int(input().rstrip());

  scores = list( map(int, sys.stdin.readline().rstrip().split()) );

  total = sum(scores);

  #
  # Как мне кажется тут есть два варианта ответа зачем нужна на первый взгляд
  # неочевидная проверка на нечётность суммы элементов массива, которая идёт
  # после данных комментариев: "простой" и сложный. :-)
  #
  # Простой: проверка нужна потому, что нечётная сумма не делится на 2 нацело.
  #
  # Сложный идёт далее:
  #
  # Сначала обратим внимание на три свойства.
  # По ним будет легко убедиться, что есть всего один вариант получить нечётное
  # число при сложении. Для этого просто переберём все цифры от 0 до 9,
  # и посмотрим на результат суммы по модулю 10, т.к. для определения
  # чётности / нечётности нас интересует лишь последний разряд числа.
  #
  # Начнём с нечётных чисел / цифр:
  #
  # [1 + 1] = 2  [3 + 3] = 6  [5 + 5] = 0  [7 + 7] = 4  [9 + 9] = 8
  # [1 + 3] = 4  [3 + 5] = 8  [5 + 7] = 2  [7 + 9] = 6
  # [1 + 5] = 6  [3 + 7] = 0  [5 + 9] = 4
  # [1 + 7] = 8  [3 + 9] = 2
  # [1 + 9] = 0
  #
  # 1) То есть сумма нечётных чисел всегда даёт чётное число.
  #
  # 2) Теперь посмотрим на сумму чётных чисел. Тут всё проще: самое первое чётное
  # число - это 2. Соответственно по определению чётных чисел следующее чётное
  # число будет находиться как минимум на расстоянии 2 от текущего. Значит любое
  # следующее чётное число будет находиться на расстоянии кратном двойке.
  # Сумму любых чётных чисел можно представить как сумму двоек, и таким образом
  # вследствии вышеизложенного итоговый результат будет чётным.
  # Опять-таки, так как нас не интересует порядок числа, можно смотреть только
  # на последний разряд:
  #
  # [ 4 + 8] = [(2 + 2) + (2 + 2 + 2 + 2)] = 2
  # [12 + 6] = [(2 * 6) + (2 * 3)]         = 8
  #
  # 3) Теперь также очевидно, что для того, чтобы получить нечётное число при
  # сложении, чётность слагаемых должна быть разной:
  #
  # [1 + 4] = 5
  # [3 + 8] = 1
  #
  # Теперь вернёмся к исходному вопросу. Пойдём от обратного.
  # Если предположить, что нижеследующая проверка необязательна, то получается,
  # что в нашем массиве есть два набора элементов, которые в сумме дают
  # нечётное число. Однако, в соответствии с рассуждениями выше, это возможно
  # только при условии, что одна из половин суммы чётная, а другая нечётная,
  # что противоречит требованию задачи - проверить, можно ли заданный массив
  # разделить на две части с *одинаковой* суммой в обоих. Получили противоречие,
  # следовательно если сумма элементов массива является нечётной, то нет смысла
  # даже пытаться искать одинаковую сумму среди его элементов - её там просто нет.
  #
  if total % 2 != 0:
    print("False");
    return;

  #
  # Поскольку ищем в массиве две половины с одинаковой суммой, то у нас
  # есть верхняя граница поиска, которая равна половине суммы всех элементов
  # массива. Другого варианта быть не может, так как две половины с одинаковой
  # суммой из исходного массива при сложении очевидно дадут сумму всех элементов
  # массива.
  #
  toSearch = total // 2;

  #
  # Имея цель для поиска, осталось лишь перебрать суммы всех подсетов исходного
  # массива и если нам удалось найти сумму элементов этого подсета равной искомой,
  # то значит массив можно разделить на две части. Забрутфорсить через
  # рекурсивный обход дерева мы очевидно не можем, т.к. не пройдём по времени
  # ( которое O(2^n) ) и памяти ( O(n*sum(array)) ).
  # Другой вариант это использовать сет из сумм, в который положить первый
  # элемент и дальше перебирать суммы всех элементов исходного массива с
  # элементами этого сета, которые будут представлять собой части уже
  # посчитанных сумм, и таким образом забутстрепить решение.
  # Но в контесте предусмотрительно выставили лимит по памяти в 8 МБ и
  # максимально возможный размер числа n в 300. И хотя размер сета из трёхсот
  # элементов в питоне как раз равен 8416 байт (если судить по sys.getsizeof),
  # по памяти в автотестах контеста мы всё равно не пройдём.
  # Поэтому придётся искать другой способ.
  #
  # На самом деле, как выяснилось в процессе гуглежа, эту проблему можно свести
  # к задаче о рюкзаке, где в качестве ёмкости рюкзака будет выступать
  # искомая полусумма (т.е. sum(elements) // 2), а в качестве предметов - числа
  # из заданного массива с ценностью равной их номиналу. И задача теперь будет
  # не собрать рюкзак с максимальной ценностью, а завершить работу алгоритма
  # как только мы наберём наш "рюкзак" до искомой суммы. Но несмотря на
  # вероятность раннего выхода, в худшем случае наш ответ будет посчитан на
  # последнем шаге и будет находиться в крайней правой ячейке массива, поэтому
  # её в любом случае нужно будет проверить по окончанию работы алгоритма.
  # Хотя я смог найти только один худший случай, 1 1 1 1 1 5, и у меня тогда
  # получается остановка на ПРЕДпоследнем шаге, но здравый смысл подсказывает,
  # что лишней эта проверка всё равно не будет.
  #
  # Не буду описывать весь процесс, он аналогичен алгоритму решения задачи о
  # рюкзаке, поэтому просто приведу конечный результат таблицы с небольшими
  # пояснениями.
  #
  # Массив для проверки: [ 8, 1, 2, 8, 2, 10, 4, 5 ], s = 40, c = 20
  #
  #         (для красоты двузначные числа представлены в виде букв)
  #
  #    |  0  1  2  3  4  5  6  7  8  9  A  1  2  3  4  5  6  7  8  9  B    <- 20
  #    |-----------------------------------------------------------------
  #    |  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
  #    |   \---------------------\
  # 8  |  0  0  0  0  0  0  0  0  8  8  8  8  8  8  8  8  8  8  8  8  8  +
  #    |                          |
  # 1  |  0  1  1  1  1  1  1  1  8  9  9  9  9  9  9  9  9  9  9  9  9
  #    |                           \---\
  # 2  |  0  1  2  3  3  3  3  3  8  9  10 11 11 11 11 11 11 11 11 11 11 +
  #    |                                  \--------------------\
  # 8  |  0  1  2  3  3  3  3  3  8  9  10 11 11 11 11 11 16 17 18 19 19 +
  #    |                                                          \--\
  # 2  |  0  1  2  3  4  5  5  5  8  9  10 11 12 13 13 13 16 17 18 19 20 +
  #    |                                                              --   <--+
  # 10 |  0  1  2  3  4  5  5  5  8  9  10 11 12 13 14 15 16 17 18 19 20      |
  #    |                                                                 сумма найдена
  # 4  |  0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19 20 можно останавливаться
  #    |
  # 5  |  0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19 20
  #
  # Таким образом имеем две группы элементов с суммой 20:
  #
  # [ 8, 2, 8, 2 ] - [ 1, 10, 4, 5 ]
  #
  # В интернете есть более оптимальное хакерское решение с O(toSearch) по памяти,
  # но я не понимаю как оно работает и что оно делает. Оно закомментировано ниже.
  #
  # Поэтому я рискнул модифицировать алгоритм рюкзака, просто убрав хранение
  # матрицы, т.к. она нам не нужна, поскольку на каждом шаге мы смотрим текущую
  # строку и предыдущую, и внезапно влез в лимиты.
  #
  dp1 = [ 0 ] * (toSearch + 1);
  dp2 = [ 0 ] * (toSearch + 1);

  for i in range(n):
    if dp1[toSearch] == toSearch:
      break;

    curScore = scores[i];

    for j in range(1, toSearch + 1):
      if j < curScore:
        dp2[j] = dp1[j];
      else:
        prev   = dp1[j];
        new    = dp1[j - curScore] + curScore;
        dp2[j] = max(prev, new);

    dp1 = dp2[:];

  if dp1[toSearch] == toSearch:
    print("True");
  else:
    print("False");

  #
  # Тут ни хрена не понятно.
  #

  '''
  dp = [ False ] * (toSearch + 1);
  dp[0] = True;

  for score in scores:
    for i in range(toSearch, score - 1, -1):
      if dp[toSearch] == True:
        print("True");
        return;

      dp[i] = (dp[i] or dp[i - score]);

  if dp[toSearch] == True:
    print("True");
  else:
    print("False");
  '''

################################################################################

if __name__ == "__main__":
  main();
