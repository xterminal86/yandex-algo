#!/usr/bin/python3

#
# Формат ввода
# В первой строке дано число n — количество элементов в первой
# последовательности (1 ≤ n ≤ 1000). Во второй строке даны n чисел
# ai (0 ≤ |ai| ≤ 10^9) — элементы первой последовательности. Аналогично в
# третьей строке дано m (1 ≤ m ≤ 1000) — число элементов второй
# последовательности. В четвертой строке даны элементы второй
# последовательности через пробел bi (0 ≤ |bi| ≤ 10^9).
#
# Формат вывода
# Сначала выведите длину найденной наибольшей общей подпоследовательности, во
# второй строке выведите индексы элементов первой последовательности, которые в
# ней участвуют, в третьей строке — индексы элементов второй последовательности.
# Нумерация индексов с единицы, индексы должны идти в корректном порядке.
#
# Если возможных НОП несколько, то выведите любую.
#

import sys;

################################################################################

def main():
  n = int(input().rstrip());
  first = sys.stdin.readline().rstrip().split();
  m = int(input().rstrip());
  second = sys.stdin.readline().rstrip().split();

  dp = [ [0 for _ in range(m + 1)] for _ in range(n + 1)];

  for i in range(n):
    for j in range(m):
      if first[i] == second[j]:
        dp[i + 1][j + 1] = 1 + dp[i][j];
      else:
        dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]);

  i = n;
  j = m;

  ans = [];

  while (i > 0) and (j > 0):
    if dp[i][j] == dp[i][j - 1]:
      j += -1;
    elif dp[i][j] == dp[i - 1][j]:
      i += -1;
    else:
      ans.append( (i, j) );
      i += -1;
      j += -1;

  ans.reverse();

  print(len(ans));

  out = [];

  for item in ans:
    out.append(item[0]);

  print(*out);

  out = [];

  for item in ans:
    out.append(item[1]);

  print(*out);

################################################################################

if __name__ == "__main__":
  main();
